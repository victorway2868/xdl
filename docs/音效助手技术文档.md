# 音效助手技术文档

## 概述

音效助手是一个集成在 Electron 应用中的功能模块，允许用户通过全局快捷键播放音效文件。该功能主要用于直播场景，让主播能够快速播放各种音效来增强直播效果。

## 核心功能

- 🎵 音效文件管理和播放
- ⌨️ 全局快捷键支持（包括小键盘）
- 🛑 一键停止所有音效
- 📦 音效包自动更新
- 🔒 界面锁定防误操作
- 🎯 拖拽排序和删除

## 技术架构

### 整体架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端 UI 层    │    │   IPC 通信层    │    │   后端处理层    │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ AudioSettings   │◄──►│   preload.ts    │◄──►│ audio.ts        │
│ MainLayout      │    │   ipc.ts        │    │ handlers/       │
│ 快捷键监听      │    │   事件桥接      │    │ 文件管理        │
│ 音效播放        │    │   类型定义      │    │ 快捷键注册      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 文件结构

```
src/
├── main/
│   ├── handlers/
│   │   └── audio.ts              # 后端音频处理逻辑
│   └── preload.ts                # IPC 预加载脚本
├── renderer/
│   ├── components/layout/
│   │   └── MainLayout.tsx        # 全局快捷键监听
│   └── pages/
│       └── AudioSettingsPage.tsx # 音效设置界面
└── shared/
    └── interfaces/
        └── ipc.ts                # IPC 接口定义
```

## 核心实现

### 1. 数据结构

#### 音效对象定义
```typescript
interface SoundEffect {
  id: string;        // 唯一标识符
  name: string;      // 显示名称
  hotkey: string;    // 快捷键组合
  position: number;  // 排序位置
  filePath?: string; // 音频文件路径（停止音效无此字段）
}
```

#### 特殊音效：停止音效
```typescript
const stopEffect: SoundEffect = {
  id: 'stop-effect',
  name: '停止',
  hotkey: '',
  position: 0,
  filePath: undefined // 停止音效不需要文件路径
};
```

### 2. 后端实现 (src/main/handlers/audio.ts)

#### 音频文件管理
```typescript
// 获取音效文件目录
function getSoundEffectsDir(): string {
  const { app } = require('electron');
  const appDataPath = app.getPath('userData');
  return path.join(appDataPath, 'SoundEffects');
}

// 扫描音频文件
async function getAudioFiles(): Promise<string[]> {
  const audioExtensions = ['.mp3', '.wav', '.ogg', '.m4a', '.aac'];
  // 递归扫描目录，返回相对路径
}
```

#### 快捷键格式转换
```typescript
function convertHotkeyFormat(hotkey: string): string {
  let electronHotkey = hotkey
    .replace(/Ctrl/g, 'CommandOrControl')
    .replace(/Meta/g, 'CommandOrControl');
  
  // 处理小键盘按键
  electronHotkey = electronHotkey
    .replace(/Numpad0/g, 'num0')
    .replace(/Numpad1/g, 'num1')
    // ... 其他小键盘按键映射
    .replace(/NumpadAdd/g, 'numadd')
    .replace(/NumpadEnter/g, 'Enter');
  
  return electronHotkey;
}
```

#### 全局快捷键注册
```typescript
async function registerGlobalHotkey(hotkey: string, identifier: string): Promise<boolean> {
  const electronHotkey = convertHotkeyFormat(hotkey);
  
  const success = globalShortcut.register(electronHotkey, () => {
    // 统一发送快捷键触发事件
    const mainWindow = BrowserWindow.getAllWindows()[0];
    if (mainWindow) {
      mainWindow.webContents.send('hotkey-triggered', { hotkey });
    }
  });
  
  return success;
}
```

#### 音效包更新机制
```typescript
async function checkSoundPackUpdates() {
  // 从服务器获取音效包列表
  const response = await axios.get('https://server.com/soundeffects.json');
  
  // 比较本地和远程版本
  const localPacks = await getLocalSoundPacks();
  const packsToDownload = response.data.files.filter(pack =>
    !localPacks.includes(pack.name)
  );
  
  return { files: packsToDownload };
}
```

### 3. 前端实现

#### 全局快捷键监听 (MainLayout.tsx)
```typescript
const MainLayout: React.FC = () => {
  const [soundEffects, setSoundEffects] = useState<SoundEffect[]>([]);
  const currentAudioRef = useRef<HTMLAudioElement | null>(null);

  // 加载音效配置
  useEffect(() => {
    const loadSoundEffects = () => {
      const savedEffects = localStorage.getItem('soundEffects');
      if (savedEffects) {
        setSoundEffects(JSON.parse(savedEffects));
      }
    };

    loadSoundEffects();
    
    // 监听配置更新事件
    const handleSoundEffectsUpdate = () => loadSoundEffects();
    window.addEventListener('soundEffectsUpdated', handleSoundEffectsUpdate);

    return () => {
      window.removeEventListener('soundEffectsUpdated', handleSoundEffectsUpdate);
    };
  }, []);

  // 全局快捷键监听
  useEffect(() => {
    const unsubscribe = window.electronAPI?.onHotkeyTriggered?.((payload) => {
      const { hotkey } = payload;
      const effect = soundEffects.find(e => e.hotkey === hotkey);
      if (effect) {
        handlePlaySound(effect);
      }
    });

    return unsubscribe;
  }, [soundEffects]);

  // 音效播放处理
  const handlePlaySound = async (effect: SoundEffect) => {
    if (effect.id === 'stop-effect') {
      // 停止当前播放
      if (currentAudioRef.current) {
        currentAudioRef.current.pause();
        currentAudioRef.current.currentTime = 0;
        currentAudioRef.current = null;
      }
      return;
    }

    // 播放新音效
    const audioUrl = await window.electronAPI?.getAudioFileUrl?.(effect.filePath);
    if (audioUrl) {
      const audio = new Audio(audioUrl);
      currentAudioRef.current = audio;
      await audio.play();
    }
  };
};
```

#### 快捷键录制 (AudioSettingsPage.tsx)
```typescript
const handleGlobalKeyDown = (e: KeyboardEvent) => {
  e.preventDefault();
  e.stopPropagation();

  // 忽略单独的修饰键
  if (['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) {
    return;
  }

  const keys: string[] = [];

  // 按固定顺序添加修饰键
  if (e.ctrlKey) keys.push('Ctrl');
  if (e.altKey) keys.push('Alt');
  if (e.shiftKey) keys.push('Shift');
  if (e.metaKey) keys.push('Meta');

  // 处理主键（包括小键盘）
  let keyName = e.key;
  
  if (e.code.startsWith('Numpad')) {
    // 小键盘特殊处理
    if (e.code === 'NumpadEnter') keyName = 'NumpadEnter';
    else if (e.code === 'NumpadAdd') keyName = 'NumpadAdd';
    // ... 其他小键盘按键
    else if (e.code.match(/^Numpad\d$/)) {
      keyName = e.code; // Numpad0-9
    }
  }
  // 其他特殊键处理
  else if (keyName === ' ') keyName = 'Space';
  else if (keyName === 'ArrowUp') keyName = 'Up';
  // ... 其他特殊键

  keys.push(keyName);
  const hotkeyString = keys.join('+');
  setCurrentHotkey(hotkeyString);
  setIsRecording(false);
};
```

### 4. IPC 通信层

#### 接口定义 (ipc.ts)
```typescript
export interface IpcApi {
  // 音频文件管理
  getAudioFiles: () => Promise<string[]>;
  getAudioFileUrl: (filePath: string) => Promise<string | null>;
  
  // 音效包管理
  checkSoundPackUpdates: () => Promise<{ files: Array<{ name: string; url: string }> } | null>;
  downloadSoundPack: (packName: string, packUrl: string) => Promise<boolean>;
  
  // 全局快捷键
  updateGlobalHotkeys: (soundEffects: SoundEffect[]) => Promise<boolean>;
  clearAllGlobalHotkeys: () => Promise<boolean>;
  onHotkeyTriggered: (cb: (payload: { hotkey: string }) => void) => () => void;
}
```

#### 预加载脚本 (preload.ts)
```typescript
const electronAPI: IpcApi = {
  // 快捷键事件监听
  onHotkeyTriggered: (cb: (payload: { hotkey: string }) => void) => {
    const listener = (_event: any, payload: { hotkey: string }) => cb(payload);
    ipcRenderer.on('hotkey-triggered', listener);
    return () => ipcRenderer.removeListener('hotkey-triggered', listener);
  },
  
  // 其他 API 实现...
};

contextBridge.exposeInMainWorld('electronAPI', electronAPI);
```

## 关键技术点

### 1. 全局快捷键支持

**支持的按键类型：**
- 功能键：F1-F12
- 修饰键组合：Ctrl+A, Alt+F1, Shift+Space
- 小键盘：Numpad0-9, NumpadAdd, NumpadEnter 等
- 特殊键：Space, Enter, Escape, 方向键等

**实现要点：**
- 前端使用 `e.code` 识别小键盘按键
- 后端转换为 Electron 支持的格式
- 统一的快捷键触发事件处理

### 2. 音效播放机制

**播放策略：**
- 使用 HTML5 Audio API 在渲染进程播放
- 支持同时只播放一个音效
- 停止音效会中断当前播放

**文件管理：**
- 音效文件存储在用户数据目录
- 支持多种音频格式：MP3, WAV, OGG, M4A, AAC
- 通过 file:// URL 访问本地文件

### 3. 状态同步机制

**跨组件通信：**
```typescript
// 音效页面更新配置
localStorage.setItem('soundEffects', JSON.stringify(soundEffects));
window.dispatchEvent(new CustomEvent('soundEffectsUpdated'));

// MainLayout 监听更新
window.addEventListener('soundEffectsUpdated', handleSoundEffectsUpdate);
```

**生命周期管理：**
- MainLayout 负责全局快捷键的完整生命周期
- AudioSettingsPage 只负责配置管理
- 应用关闭时自动清理资源

### 4. 用户体验优化

**界面交互：**
- 拖拽排序和删除
- 锁定模式防误操作
- 实时快捷键录制
- 播放状态视觉反馈

**错误处理：**
- 音频文件不存在的处理
- 快捷键冲突检测
- 网络更新失败的降级

## 部署和配置

### 音效包服务器配置

服务器需要提供 JSON 格式的音效包列表：

```json
{
  "files": [
    {
      "name": "basic_sounds",
      "url": "https://server.com/packs/basic_sounds.zip"
    },
    {
      "name": "funny_sounds", 
      "url": "https://server.com/packs/funny_sounds.zip"
    }
  ]
}
```

### 本地存储结构

```
用户数据目录/
├── SoundEffects/           # 音效文件目录
│   ├── basic_sounds/       # 音效包1
│   │   ├── beep.wav
│   │   └── click.mp3
│   └── funny_sounds/       # 音效包2
│       ├── laugh.wav
│       └── applause.mp3
└── localStorage
    └── soundEffects        # 音效配置JSON
```

## 性能考虑

### 内存管理
- 音频对象及时释放
- 避免多个音频同时播放
- 组件卸载时清理监听器

### 文件访问优化
- 使用相对路径存储配置
- 延迟加载音频文件
- 缓存文件 URL 避免重复计算

### 快捷键性能
- 全局快捷键数量限制
- 避免快捷键冲突
- 高效的快捷键查找算法

## 扩展性设计

### 功能扩展点
- 音效分类和标签
- 音量控制和淡入淡出
- 音效预设和场景切换
- 云端音效库同步

### 架构扩展
- 插件化音效处理器
- 自定义音效格式支持
- 多设备音效同步
- API 接口开放

## 故障排除

### 常见问题

1. **快捷键不生效**
   - 检查是否有其他应用占用快捷键
   - 确认快捷键格式是否正确
   - 查看控制台错误日志

2. **音效播放失败**
   - 检查音频文件是否存在
   - 确认文件格式是否支持
   - 检查文件权限

3. **音效包更新失败**
   - 检查网络连接
   - 确认服务器地址正确
   - 查看下载权限

### 调试方法

```typescript
// 开启详细日志
loggerService.addLog('info', `Hotkey triggered: ${hotkey}`, 'main');

// 检查音效配置
console.log('Current sound effects:', soundEffects);

// 监控快捷键注册
console.log('Registered hotkeys:', globalHotkeys.size);
```

## 总结

音效助手通过 Electron 的全局快捷键 API 和 HTML5 Audio API 的结合，实现了一个功能完整、性能良好的音效播放系统。其核心设计思想是：

1. **分离关注点**：UI 层专注交互，业务层处理逻辑，通信层桥接前后端
2. **统一处理**：所有音效（包括停止）使用相同的快捷键机制
3. **全局生命周期**：快捷键监听在应用级别管理，不受页面切换影响
4. **用户友好**：支持丰富的快捷键类型，提供直观的配置界面

该实现为直播音效需求提供了完整的解决方案，同时保持了良好的扩展性和维护性。